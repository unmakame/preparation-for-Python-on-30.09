
# 1
 ## Циклические ссылки, приведите пример 
 Циклические ссылки возникают когда два или более обьекста ссылаются друг на друга, это может препятствовать освобождению памяти, так как счетчики ссылок таких обьектов не может достигнуть нуля естественным образом.
 ```
 a = []
 b = [a]
 a.append(b) # создание циклической ссылки 
 ```
 ## Наследование классов в ООП, меняется ли както порядок вызова методов, если да объясните, если нет, тоже
   НАследование это один из принципов ООП который позволяет создавать классы на основе существующих, родительский -> дочерний. Дочерние классы наследуют атрибуты и методы родительского класса, это облегчает повторное использование кода. При множественном наследовании порядок вызова методов меняется и определяется с помощью MRO (слева направов порядке обьявления)
 ## Напишите класс vector для сложения, умножения, деления, вычитания 
  ```
class Vector:
    def __init__(self,x,y):
        self.x = x
        self.y = y

    def add(self, other):
        return (self.x + other.x, self.y + other.y)
    
    def mull(self,other):
        return (self.x*other.x, self.y*other.y)
    

    def div(self,other):
        return (self.x/other.x, self.y/other.y)
    
    def sub(self,other):
        return (self.x - other.x, self.y - other.y)
```
# 2
 ## Разница между атрибутами класса и атрибутами объекта пример кода
  Атрибуты класса принадлежат и одинаковы для всех экземпляров класса, в то время как атрибуты обьекта относятся только к одному отдельному экземпляру класса.
  ```
class People:
    rassa = 'Homo sapiens'
    def __init__(self, age, pol):
        self.age = age
        self.pol = pol
        
  ```
 ## --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 ## Напишите класс AccountManager, у которого есть функции add_user(username, password) добавляет пользователя с хэшированным паролем. authenticate(username, password) проверяет хэш с password с хэшем в  AccountManager.  remove_user(username) удаляет пользователя. для хэшей использовать hashlib
 ```
import hashlib
class AccountManager:
    def __init__(self):
        self._accounts = {}
    def _hash(self, password):
        return hashlib.sha256(password.encode()).hexdigest()
    def add_user(self, username, password):
        self._accounts[username] = self._hash(password)
    def authenticate(self, username, password):
        stored = self._accounts.get(username)
        return stored == self._hash(password)
    def remove_user(self, username):
        self._accounts.pop(username, None)
```
# 3
 ## можно ли изменить атрибут класса через его экземпляр? что произойдет
Если изменить атрибут класса через экземпляр, это созжаст новый атрибут экземпляра с тем же именем который будет скрывать атрибут класса. Атрибут класса при этом не изменится 
```
class Myclass:
    s = 10

o1 = Myclass()
o2 = Myclass()

o1.s = 20

print(o1.s,o2.s,Myclass.s)
```
 ## 
 ## решето эратосфена с помощью numpy без циклов
 ```
import numpy as np
n = 100
is_prime = np.ones(n+1, bool)
is_prime[0:2] = 0
is_prime[np.arange(2, int(n**0.5)+1)[:, None] * np.arange(2, n//2+1)] = 0
print(np.nonzero(is_prime)[0])

```
# 4
 ## что произойдет если забыть вызывать super().__init__() 
 Если забыть вызвать super()__init__(), то конструктор родительского класса не выполнится, атрибуты родительского класса инициализированные в __init__ не будут созданы в дочернем обьекте, также нарушиться работа методов зависящих от этих атрибутов и в множественном наследовании нарушиться порядок вызова методов.
 ## миксин 
  Миксин это класс который предоставляет методы другим классам, но не рассматривается как базовый класс, он позволяет другим классам повторно использовать его интерфейс и реализацию без превращения в суперкласс.Миксины аналогичны композиции, но создают более сильную связь.
 ## написать класс username
 ```
import hashlib
class AccountManager:
    def __init__(self):
        self._accounts = {}
    def _hash(self, password):
        return hashlib.sha256(password.encode()).hexdigest()
    def add_user(self, username, password):
        self._accounts[username] = self._hash(password)
    def authenticate(self, username, password):
        stored = self._accounts.get(username)
        return stored == self._hash(password)
    def remove_user(self, username):
        self._accounts.pop(username, None)
```
# 5
 ## Почему важно, чтобы метод new возвращал объект именно того класса, от имени которого был вызван?
 Метод new отвечает за создание обьекта, выделения памяти под него и возврата ссылки на обьект, поэтому важно чтобы он возвращал обьект этогоже класса, потомучто иначе __init__ не будет вызван, а вызовется __init__ класса возвращенного ответа, обьект не будет иметь ожидаемую структуру и атрибуты
 ## как создать массив в numpy?
В нампае массивы можно задавать разными способами, np.array([]) - из списка или кортежа, np.arange(start,stop,step) - диапазон с шагом, np.linespace(start,stop,step) - диапазон с количеством элементов, np.zeros(shape), np.ones(shape), np.full(shape, value) — массивы с одинаковыми значениями, np.random.* -- случайные массивы
 ##
# 6
 ## сеттер
Сеттер  - метод который позволяет безопасно задавать значения приватным атрибутам обьекта, предварительно выполняя проверки или преобразования перед присвоением.
 ## миксин 
 Миксин это класс который предоставляет методы другим классам но не рассматривается как базовый класс, он позволяет другим классам повторно использовать его интерыейс и реализацию без превращения в суперкласс. Миксины аналогичны компощиции, но создают более сильную связь
 ## решето Эратосфена
  ```
import numpy as np
n = 100
is_prime = np.ones(n+1, bool)
is_prime[0:2] = 0
is_prime[np.arange(2, int(n**0.5)+1)[:, None] * np.arange(2, n//2+1)] = 0
print(np.nonzero(is_prime)[0])

```
# 7
 ## чио если не вызвать super().__init__()
  Если забыть вызвать super()__init__(), то конструктор родительского класса не выполнится, атрибуты родительского класса инициализированные в __init__ не будут созданы в дочернем обьекте, также нарушиться работа методов зависящих от этих атрибутов и в множественном наследовании нарушиться порядок вызова методов.
 ## in-place
 ## написать класс Vector, ColoredVector
# 8
 ## может ли геттер или сеттер иметь имя отличное от атрибута

 
 ## в чем преимущество использования миксинов
 ## 
# 9
 ## Что такое dataclass в Python. Отметьте все различия с простым class.Напишите простой class с использованием dataclass.

 
 ## Что такое отношения в UML,распишите все виды отношений. Изобразите диаграмму отношений в UML.

 
 ## Напишите class Vector, метод инициализации координат х,у.Метод суммирования векторов __add__(self,other),вычитания также, умножения на скаляр __mul__(self,scalar).Также подкласс color который вернет или выведет сообщение о характеристиках вектора

# 10
 ## метод _new_ что будет если вернёт другой класс

 
 ## когда лучше использовать миксины,а когда композицию

 
 ## Data frame, информация о продажах,найти максимальную прибыль от продажи товара 
# 11
 ## что такое dataclass. привести пример

 
 ## как определить абстрактный метод. привести пример

 
 ## Напишите класс AccountManager, у которого есть функции add_user(username, password) добавляет пользователя с хэшированным паролем. authenticate(username, password) проверяет хэш с password с хэшем в  AccountManager.  remove_user(username) удаляет пользователя. для хэшей использовать hashlib

# 12
 ## Счётчик ссылок, для чего он нужен при работе с памятью
 ## super() в множественном наследовании
 ##
# 13
 ## что будет, если у атрибута класса и атрибута объекта будет одинаковое название. привести пример 
 ## как выделить строку или столбец в dataframe. привести пример 
 ## написать функцию, возвращающую массив простых чисел до н включительно, используя numpy без циклов'
  ```
import numpy as np
n = 100
is_prime = np.ones(n+1, bool)
is_prime[0:2] = 0
is_prime[np.arange(2, int(n**0.5)+1)[:, None] * np.arange(2, n//2+1)] = 0
print(np.nonzero(is_prime)[0])

```
# 14 
 ## ссылки, как они связаны с памятью
 ## композиция
 ## гапиоите программу которая будет обрабатываать количество товара, время, сумму проданного. нужно чтобы программа высчитала сумму проданного и нашла максимальную, также сделать график с товараии и их суммами
# 15
 ## можно ли self использовать вне класса, если можно или нельзя то обосновать 
 ## в пандас отличие dataframe от series, привести код пример инициализации их обоих 
 ## 
# 16
 ## почему в init должен подаваться self, что будет если забыть это сделать
 ## логическая индексация в numpy, привести пример кода
 ## класс пользователей, котооый добавляет пользователя (имя и пароль), проверяет введенный пароль на совпадение с хэшируемым, удаляет пользователя, использовать библиотеку hashlib
 ```
import hashlib
class AccountManager:
    def __init__(self):
        self._accounts = {}
    def _hash(self, password):
        return hashlib.sha256(password.encode()).hexdigest()
    def add_user(self, username, password):
        self._accounts[username] = self._hash(password)
    def authenticate(self, username, password):
        stored = self._accounts.get(username)
        return stored == self._hash(password)
    def remove_user(self, username):
        self._accounts.pop(username, None)
```    

