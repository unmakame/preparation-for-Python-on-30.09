
# 1 Билет
 ## Циклические ссылки, приведите пример 
 Циклические ссылки возникают когда два или более обьекста ссылаются друг на друга, это может препятствовать освобождению памяти, так как счетчики ссылок таких обьектов не может достигнуть нуля естественным образом.
 ```
 a = []
 b = [a]
 a.append(b) # создание циклической ссылки 
 ```
 ## Наследование классов в ООП, меняется ли както порядок вызова методов, если да объясните, если нет, тоже
   НАследование это один из принципов ООП который позволяет создавать классы на основе существующих, родительский -> дочерний. Дочерние классы наследуют атрибуты и методы родительского класса, это облегчает повторное использование кода. При множественном наследовании порядок вызова методов меняется и определяется с помощью MRO (слева направов порядке обьявления)
 ## Напишите класс vector для сложения, умножения, деления, вычитания 
  ```
class Vector:
    def __init__(self,x,y):
        self.x = x
        self.y = y

    def add(self, other):
        return (self.x + other.x, self.y + other.y)
    
    def mull(self,other):
        return (self.x*other.x, self.y*other.y)
    

    def div(self,other):
        return (self.x/other.x, self.y/other.y)
    
    def sub(self,other):
        return (self.x - other.x, self.y - other.y)
```
# 2 Билет
 ## Разница между атрибутами класса и атрибутами объекта пример кода
  Атрибуты класса принадлежат и одинаковы для всех экземпляров класса, в то время как атрибуты обьекта относятся только к одному отдельному экземпляру класса.
  ```
class People:
    rassa = 'Homo sapiens'
    def __init__(self, age, pol):
        self.age = age
        self.pol = pol
        
  ```
 ## --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 ## Напишите класс AccountManager, у которого есть функции add_user(username, password) добавляет пользователя с хэшированным паролем. authenticate(username, password) проверяет хэш с password с хэшем в  AccountManager.  remove_user(username) удаляет пользователя. для хэшей использовать hashlib
 ```
import hashlib
class AccountManager:
    def __init__(self):
        self._accounts = {}
    def _hash(self, password):
        return hashlib.sha256(password.encode()).hexdigest()
    def add_user(self, username, password):
        self._accounts[username] = self._hash(password)
    def authenticate(self, username, password):
        stored = self._accounts.get(username)
        return stored == self._hash(password)
    def remove_user(self, username):
        self._accounts.pop(username, None)
```
# 3 Билет
 ## можно ли изменить атрибут класса через его экземпляр? что произойдет
Если изменить атрибут класса через экземпляр, это созжаст новый атрибут экземпляра с тем же именем который будет скрывать атрибут класса. Атрибут класса при этом не изменится 
```
class Myclass:
    s = 10

o1 = Myclass()
o2 = Myclass()

o1.s = 20

print(o1.s,o2.s,Myclass.s)
```
 ## 
 ## решето эратосфена с помощью numpy без циклов
 ```
import numpy as np
n = 100
is_prime = np.ones(n+1, bool)
is_prime[0:2] = 0
is_prime[np.arange(2, int(n**0.5)+1)[:, None] * np.arange(2, n//2+1)] = 0
print(np.nonzero(is_prime)[0])

```
# 4 Билет
 ## что произойдет если забыть вызывать super().__init__() 
 Если забыть вызвать super()__init__(), то конструктор родительского класса не выполнится, атрибуты родительского класса инициализированные в __init__ не будут созданы в дочернем обьекте, также нарушиться работа методов зависящих от этих атрибутов и в множественном наследовании нарушиться порядок вызова методов.
 ## миксин 
  Миксин это класс который предоставляет методы другим классам, но не рассматривается как базовый класс, он позволяет другим классам повторно использовать его интерфейс и реализацию без превращения в суперкласс.Миксины аналогичны композиции, но создают более сильную связь.
 ## написать класс username
 ```
import hashlib
class AccountManager:
    def __init__(self):
        self._accounts = {}
    def _hash(self, password):
        return hashlib.sha256(password.encode()).hexdigest()
    def add_user(self, username, password):
        self._accounts[username] = self._hash(password)
    def authenticate(self, username, password):
        stored = self._accounts.get(username)
        return stored == self._hash(password)
    def remove_user(self, username):
        self._accounts.pop(username, None)
```
# 5 Билет
 ## Почему важно, чтобы метод new возвращал объект именно того класса, от имени которого был вызван?
 Метод new отвечает за создание обьекта, выделения памяти под него и возвращает этот обьект, поэтому важно чтобы он возвращал обьект этогоже класса, потомучто иначе __init__ не будет вызван, а вызовется __init__ класса возвращенного ответа, обьект не будет иметь ожидаемую структуру и атрибуты
 ## как создать массив в numpy?
В нампае массивы можно задавать разными способами, np.array([]) - из списка или кортежа, np.arange(start,stop,step) - диапазон с шагом, np.linespace(start,stop,step) - диапазон с количеством элементов, np.zeros(shape), np.ones(shape), np.full(shape, value) — массивы с одинаковыми значениями, np.random.* -- случайные массивы
 ##
# 6 Билет
 ## сеттер
Сеттер  - метод который позволяет безопасно задавать значения приватным атрибутам обьекта, предварительно выполняя проверки или преобразования перед присвоением.
 ## миксин 
 Миксин это класс который предоставляет методы другим классам но не рассматривается как базовый класс, он позволяет другим классам повторно использовать его интерыейс и реализацию без превращения в суперкласс. Миксины аналогичны компощиции, но создают более сильную связь
 ## решето Эратосфена
  ```
import numpy as np
n = 100
is_prime = np.ones(n+1, bool)
is_prime[0:2] = 0
is_prime[np.arange(2, int(n**0.5)+1)[:, None] * np.arange(2, n//2+1)] = 0
print(np.nonzero(is_prime)[0])

```
# 7 Билет
 ## чио если не вызвать super().__init__()
  Если забыть вызвать super()__init__(), то конструктор родительского класса не выполнится, атрибуты родительского класса инициализированные в __init__ не будут созданы в дочернем обьекте, также нарушиться работа методов зависящих от этих атрибутов и в множественном наследовании нарушиться порядок вызова методов.
 ## in-place
  In-place (на месте) - это операции, которые модифицируют объект не создавая новый, а изменяя существующий.
 ## написать класс Vector, ColoredVector
 
# 8 Билет
 ## может ли геттер или сеттер иметь имя отличное от атрибута
 Геттеры и сеттеры в объектно-ориентированном программировании могут иметь имена, отличные от имени атрибута, к которому они предоставляют доступ. Атрибут представляет собой внутреннее состояние объекта, в то время как геттеры и сеттеры являются методами доступа к этому состоянию. Их имена могут не совпадать, поскольку они выполняют разные семантические роли: атрибут хранит данные, а методы доступа могут содержать дополнительную логику валидации, преобразования или вычисления производных значений.
 Но на практике геттеры и сеттеры обчно используют @properly обычно совпадающее с именем атрибута
 ## в чем преимущество использования миксинов
 Миксин позволяет другим классам повторно использовать его интерфейс и реализацию без превращения в суперкласс. Он реализует уникальное поведение, которое вы можете агрегировать к другим несвязанным классам. Миксины аналогичны композиции, но создают более сильную связь.
 Преимущества
  Повторное использование кода: Миксины позволяют избежать дублирования кода, предоставляя общую функциональность, которая может быть повторно использована в различных     классах.
  Гибкость: Они предоставляют гибкий способ добавления функциональности к классам без изменения их основной иерархии.
  Чистота дизайна: Использование миксинов может помочь сохранить чистоту и организованность вашего кода, делая его более модульным и легким для понимания.

# 9 Билет
 ## Что такое dataclass в Python. Отметьте все различия с простым class.Напишите простой class с использованием dataclass.
   dataclass - это декоратор введенный в python 3.7, предназначенный для упрощени написани классов, главным образом используемых для хранения данных Он автоматически добавляет специальные методы, включая __init__, __repr__, __eq__, и, при необходимости, __hash__, в классы, что уменьшает объем шаблонного кода.
   
    ```
      fromrom dataclasses import dataclass
      @dataclass
      class Server:
          name: str
          ip: str
          role: str
    ```
 
 ## Что такое отношения в UML,распишите все виды отношений. Изобразите диаграмму отношений в UML.
  В UML под отношениями подразоумеваются связи между классами, они бывают 
  Ассоциация, обычная связь между классами бывает двухстороняяя или односторонняя, показывает что один класс знает о существовании другого
  Агрегация - частный видассоциации показывает отношения целое -> часть показывается пустым ромбом у класса целого
  Композиция - более сильная форма агрегации, части не могут существовать без целого, показывается закрашенным ромбом у целого 
  Реализация - класс реализует интерфейс, обозначается пунктирной стрелкой с обычным треугольником
  Композиция - моделирует отношение имеет, один класс может вклучать в себя один или несколько обьектов других классов 
  <div style="display: flex; gap: 20px; align-items: center;">
    <img src="https://github.com/user-attachments/assets/7f08ed68-f1c5-4d21-97e3-17afb30a0b38" alt="Наследование" width="242" height="343" style="object-fit: contain;">
    <img src="https://github.com/user-attachments/assets/bab16f1e-1c42-44f2-a3b3-c528a62296a9" alt="Композиция" width="249" height="348" style="object-fit: contain;">
</div>


 
 ## Напишите class Vector, метод инициализации координат х,у.Метод суммирования векторов __add__(self,other),вычитания также, умножения на скаляр __mul__(self,scalar).Также подкласс color который вернет или выведет сообщение о характеристиках вектора
 ```
class Vector:
    def __init__(self,x,y):
        self.x = x
        self.y = y

    def add(self, other):
        return (self.x + other.x, self.y + other.y)
    
    def __mul__(self,scalar):
        return (self.x * scalar, self.y * scalar)

    def div(self,other):
        return (self.x/other.x, self.y/other.y)
    
    def sub(self,other):
        return (self.x - other.x, self.y - other.y)

class ColoredVector(Vector):
    def __init__(self, x, y, color):
        super().__init__(x, y)
        self.color = color
    def info(self): return f"({self.x},{self.y}),{self.color}"
```
# 10 Билет
 ## метод _new_ что будет если вернёт другой класс
 если метод new вернет другой класс, то конструктор init этого класса не вызовется,а вызовется конструктор возвращенного класса, обьект создастся и вызовется как экземпляр другого класса, а исходный класс не учавствует в реализации

 ## когда лучше использовать миксины,а когда композицию
 Миксины лучше использовать, когда нужно добавить отдельную, независимую функциональность к разным классам без создания громоздкой иерархии наследования. Они подходят для повторного использования кода, который не зависит от состояния объекта. Композицию используют, когда объект состоит из других объектов и нужно включить их состояние и поведение, то есть для отношений «has-a». Композиция более гибкая, позволяет динамически заменять компоненты и избегает проблем множественного наследования. Таким образом, миксины применяют для расширения поведения, а композицию — для включения объектов с собственным состоянием.
 
 ## Data frame, информация о продажах,найти максимальную прибыль от продажи товара 
 ```
import pandas as pd
data = {
    'Товар': ['A', 'B', 'C', 'D'],
    'Продажи': [100, 150, 120, 90],
    'Цена': [10, 20, 15, 25],
    'Себестоимость': [6, 12, 10, 18]
}
df = pd.DataFrame(data)
df['Прибыль'] = df['Продажи'] * (df['Цена'] - df['Себестоимость'])
max_profit = df['Прибыль'].max()
max_profit_item = df.loc[df['Прибыль'].idxmax(), 'Товар']

print(f"Максимальная прибыль: {max_profit} у товара {max_profit_item}")
```
# 11 Билет
 ## что такое dataclass. привести пример
  dataclass - это декоратор введенный в python 3.7, предназначенный для упрощени написани классов, главным образом используемых для хранения данных Он автоматически добавляет специальные методы, включая __init__, __repr__, __eq__, и, при необходимости, __hash__, в классы, что уменьшает объем шаблонного кода.
    ```
      fromrom dataclasses import dataclass
      @dataclass
      class Server:
          name: str
          ip: str
          role: str
    ```
 
 ## как определить абстрактный метод. привести пример
В Python абстрактный метод — это метод, который объявлен в базовом классе, но не имеет реализации. Он задаёт обязательный интерфейс для всех подклассов, которые должны этот метод реализовать. Такие методы создаются с помощью модуля abc и декоратора @abstractmethod
```
from abc import ABC, abstractmethod

class Animal(ABC):
    @abstractmethod
    def sound(self):
        pass

class Dog(Animal):
    def sound(self):
        return "Гав"
```

 
 ## Напишите класс AccountManager, у которого есть функции add_user(username, password) добавляет пользователя с хэшированным паролем. authenticate(username, password) проверяет хэш с password с хэшем в  AccountManager.  remove_user(username) удаляет пользователя. для хэшей использовать hashlib
 ```
import hashlib
class AccountManager:
    def __init__(self):
        self._accounts = {}
    def _hash(self, password):
        return hashlib.sha256(password.encode()).hexdigest()
    def add_user(self, username, password):
        self._accounts[username] = self._hash(password)
    def authenticate(self, username, password):
        stored = self._accounts.get(username)
        return stored == self._hash(password)
    def remove_user(self, username):
        self._accounts.pop(username, None)
```
# 12 Билет
 ## Счётчик ссылок, для чего он нужен при работе с памятью
Счётчик ссылок — это механизм управления памятью, который отслеживает, сколько объектов ссылаются на данный объект. Когда количество ссылок на объект становится нулевым, память, занимаемая этим объектом, автоматически освобождается. Он нужен для автоматического удаления ненужных объектов, предотвращения утечек памяти и упрощения управления жизненным циклом объектов.

 ## super() в множественном наследовании
 В Python super() в множественном наследовании используется для вызова метода следующего класса в порядке разрешения методов (MRO). Он позволяет корректно вызывать методы всех базовых классов без дублирования кода и обеспечивает последовательное выполнение методов родителей. Таким образом, super() предотвращает повторные вызовы одного и того же метода и обеспечивает согласованное поведение при сложной иерархии классов.
 ##
# 13 Билет
 ## что будет, если у атрибута класса и атрибута объекта будет одинаковое название. привести пример 
 Если у атрибута класса и атрибута объекта одинаковое название, при обращении через экземпляр будет использоваться атрибут объекта, который перекрывает атрибут класса. Атрибут класса при этом остаётся неизменным и доступен через сам класс. Таким образом, атрибут объекта имеет приоритет над атрибутом класса при доступе через экземпляр.
 ```
class test:
    value = 11
    def __init__(self, value):
        self.value = value

```
 ## как выделить строку или столбец в dataframe. привести пример 
 В pandas столбец DataFrame выделяется через df['имя_столбца'] или df.имя_столбца, а строка — через df.loc[индекс] (по метке) или df.iloc[позиция] (по числовой позиции). 
```
import pandas as pd

df = pd.DataFrame({'A':[1,2,3],'B':[4,5,6]})

col = df['A']      
row = df.loc[0]     

```
 ## написать функцию, возвращающую массив простых чисел до н включительно, используя numpy без циклов'
  ```
import numpy as np
n = 100
is_prime = np.ones(n+1, bool)
is_prime[0:2] = 0
is_prime[np.arange(2, int(n**0.5)+1)[:, None] * np.arange(2, n//2+1)] = 0
print(np.nonzero(is_prime)[0])

```
# 14 Билет
 ## ссылки, как они связаны с памятью
 Счётчик ссылок — это механизм управления памятью, который отслеживает, сколько объектов ссылаются на данный объект. Когда количество ссылок на объект становится нулевым, память, занимаемая этим объектом, автоматически освобождается. Он нужен для автоматического удаления ненужных объектов, предотвращения утечек памяти и упрощения управления жизненным циклом объектов.
 ## композиция
 Композиция — это принцип объектно-ориентированного проектирования, моделирующий отношение «имеет». В композиции один класс (композитный) содержит объект другого класса (компонента). Композитный класс не наследует интерфейс компонента, но может использовать его методы и данные.
Связь считается слабо связанной, потому что изменения в компоненте редко влияют на композитный класс, а изменения в композитном классе не затрагивают компонент. Это повышает гибкость и упрощает адаптацию к новым требованиям.
В отличие от наследования, композиция обычно более гибкая и позволяет повторно использовать код компонентов без жёсткой привязки к их интерфейсу.
 ## гапиоите программу которая будет обрабатываать количество товара, время, сумму проданного. нужно чтобы программа высчитала сумму проданного и нашла максимальную, также сделать график с товараии и их суммами
```
import pandas as pd
import matplotlib.pyplot as plt

df = pd.DataFrame({
    'Товар': ['A','B','C','D','A','B','C'],
    'Количество':[10,5,8,2,7,3,6],
    'Цена':[100,200,150,300,100,200,150]
})

s = (df['Количество']*df['Цена']).groupby(df['Товар']).sum()
print(s.idxmax(), s.max())
s.plot(kind='bar'); plt.show()
``` 
# 15 Билет
 ## можно ли self использовать вне класса, если можно или нельзя то обосновать 
Нельзя. self — это просто имя первого параметра метода экземпляра класса, которое по соглашению используют разработчики Python для ссылки на текущий объект. Вне класса self не имеет смысла, так как нет объекта, к которому оно могло бы относиться. Можно назвать переменную self где угодно, но она не будет автоматически ссылкой на объект класса.
 ## в пандас отличие dataframe от series, привести код пример инициализации их обоих 
 В pandas Series — это одномерный массив с индексами, а DataFrame — это двумерная таблица, состоящая из строк и столбцов как матрица 
 ```
import pandas as pd

s = pd.Series([10, 20, 30], index=['a','b','c'])
print(s)

df = pd.DataFrame({'A':[1,2,3], 'B':[4,5,6]})
print(df)
```
 ## 
# 16 Билет
 ## почему в init должен подаваться self, что будет если забыть это сделать
 self в методе __init__ обязателен, потому что он ссылается на создаваемый экземпляр класса и позволяет присваивать значения его атрибутам. Если self не указать, Python не сможет передать объект в метод, и при создании экземпляра возникнет TypeError.
 ## логическая индексация в numpy, привести пример кода
 Логическая индексация в NumPy — это способ выбора элементов массива с помощью логических условий. Создаётся булев массив того же размера, где True соответствует элементам, удовлетворяющим условию, а False — нет. При применении этого булева массива к исходному массиву возвращаются только элементы с True. Такой метод удобен для фильтрации и обработки данных без использования циклов.
 ```
import numpy as np

arr = np.array([1, 2, 3, 4, 5])
print(arr[arr > 3])      # [4 5]
print(arr[arr % 2 == 0]) # [2 4]

```
 ## класс пользователей, котооый добавляет пользователя (имя и пароль), проверяет введенный пароль на совпадение с хэшируемым, удаляет пользователя, использовать библиотеку hashlib
 ```
import hashlib
class AccountManager:
    def __init__(self):
        self._accounts = {}
    def _hash(self, password):
        return hashlib.sha256(password.encode()).hexdigest()
    def add_user(self, username, password):
        self._accounts[username] = self._hash(password)
    def authenticate(self, username, password):
        stored = self._accounts.get(username)
        return stored == self._hash(password)
    def remove_user(self, username):
        self._accounts.pop(username, None)
```    

